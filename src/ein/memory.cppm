module;

#include <sys/mman.h> // munmap
#include <limits>
#include <memory>
#include <string.h> // strdup
#include "attributes.hpp"

export module ein.memory;

namespace ein {

export template<typename T>
concept trivially_destructible
      = std::is_trivially_destructible_v<std::remove_extent_t<T>>;

/// \private
export struct c_munmap {
  size_t size;
  void operator()(void * p) const noexcept {
    if (p!= nullptr)
      munmap(p, size);
  }
};

/// \ingroup memory_group
export
using mmap_ptr = std::unique_ptr<void,c_munmap>;

/// \ingroup memory_group
export
EIN(nonnull(1))
mmap_ptr make_mmap_ptr(void * p, size_t size) {
  return mmap_ptr(p,c_munmap(size));
}

/// \private
export
struct c_free {
  template <typename T>
  void operator()(T *p) const {
    std::free(const_cast<std::remove_const_t<T>*>(p));
  }
};

/// \brief a unique pointer to trivially destructible memory managed by malloc/free
/// \tparam T type
/// \ingroup memory_group
export
template<trivially_destructible T>
using unique_c_ptr = std::unique_ptr<T, c_free>;

// prove that we don't any extra storage
static_assert(sizeof(char *)== sizeof(unique_c_ptr<char>),"");

/// \brief a unique pointer to a c string managed by malloc/free.
/// useful if taking posession of a string generated by an external source
/// \ingroup memory_group
export
using unique_str = unique_c_ptr<char const>;

/// \brief copies a unique_ptr to a c string, freed by `std::free`.
/// easy to capture in a lambda
/// \ingroup memory_group
export
EIN(nodiscard,inline,pure,nonnull(1),null_terminated_string_arg(1))
unique_str dup(const char * string) noexcept {
  return unique_str { strdup(string) };
}

} //namespace ein
